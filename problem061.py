"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle    P[3, n] = n(n + 1) / 2      1, 3, 6, 10, 15, ...
Square      P[4, n] = n^2               1, 4, 9, 16, 25, ...
Pentagonal  P[5, n] = n(3n - 1) / 2     1, 5, 12, 22, 35, ...
Hexagonal   P[6, n] = n(2n - 1)         1, 6, 15, 28, 45, ...
Heptagonal  P[7, n] = n(5n - 3) / 2     1, 7, 18, 34, 55, ...
Octagonal   P[8, n] = n(3n - 2)         1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1.  The set is cyclic, in that the last two digits of each number is the first
    two digits of the next number (including the last number with the first).

2.  Each polygonal type: triangle (P[3, 127] = 8128), square (P[4, 91] = 8281),
    and pentagonal (P[5, 44] = 2882), is represented by a different number in
    the set.

3.  This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
"""

import math
import itertools


def polygon(p, n):
    """Generates the nth polygonal number for polygon p."""
    return n * ((p - 2) * n + (4 - p)) // 2


def polygon_finder(p, x):
    """Finds the position of the smallest polygon p number greater than x."""
    n = ((p - 4) + ((4 - p) ** 2 - 4 * (p - 2) * -2 * x) ** 0.5) / (2 * p - 4)
    return math.ceil(n)


def check_cyclic(a, b, n):
    """Checks if b is cyclic with a to n digits."""
    a_cycle = a % 10 ** n
    b_cycle = b // 10 ** max((math.ceil(math.log10(b)) - n), 0)
    if a_cycle == b_cycle:
        return True
    else:
        return False


def find_index(n, l):
    """Finds the first index of a number in a sorted list that is greater than
    n."""
    return next(x[0] for x in enumerate(l) if x[1] >= n)


def poly_cyclic(x, p, n):
    """Returns True if there exists a polygon that is cyclic with n in list
    p to n digits."""
    d = x % 10 ** n
    i = find_index(d * 10 ** n, p)
    if p[i] >= (d + 1) * 10 ** n:
        return []
    return p[i:find_index((d + 1) * 10 ** n, p)]


def process_cyclicals(polygons, perm_list, matches, array, length):
    for item in array:
        for number in poly_cyclic(
          item[length-2], polygons[perm_list[length-1]], 2):
            item.append(number)
    array = [x for x in array if len(x) == length]
    if length == 6:
        for match in array:
            if len(match) == 6:
                matches.append(match)
    return array


def poly_cyclic_finder(digits, c_digits, poly):
    """Finds cyclic polygon numbers of a certain length that are cyclic and
    represent all polygonal numbers up to poly"""
    polygons = []
    for p in range(3, poly+1):
        polygons.append([polygon(p, x) for x in range(
            polygon_finder(p, 10**(digits-1)), polygon_finder(p, 10**digits))])

    permutations = list(itertools.permutations(range(0, poly-2)))

    matches = []
    for perm_list in permutations:
        cycles = []
        p = polygons[perm_list[0]]
        for item in p:
            for number in poly_cyclic(item, polygons[perm_list[1]], c_digits):
                cycles.append([item, number])
        for n in range(3, poly-1):
            cycles = process_cyclicals(polygons, perm_list, matches, cycles, n)

    matches = [x for x in matches if check_cyclic(x[-1], x[0], c_digits)]

    return matches


if __name__ == '__main__':
    print(sum(poly_cyclic_finder(4, 2, 8)[0]))
